<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Pathogen networks</title>
	<style>
		body {
			font-family: sans-serif;
		}
		h1 {
			font-weight: normal;
			color: #3d3d3d;
			margin-left: 15px;
		}
		.links line {
			stroke: #999;
			stroke-opacity: 0.6;
		}

		.nodes circle {
			stroke: #fff;
			stroke-width: 1.5px;
		}
	</style>
</head>

<body>
	<h1>global pathogen research network</h1>
	<svg></svg>


<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
(function () {

		var width = window.innerWidth,
			height = window.innerHeight;

		var svg = d3.select("svg")
			.attr('width', width)
			.attr('height', height);

		var color = d3.scaleOrdinal(d3.schemeCategory20);

		var simulation = d3.forceSimulation()
			.force("link", d3.forceLink().id(function (d) {
				return d.id;
			}))
			.force("charge", d3.forceManyBody())
			.force("center", d3.forceCenter(width / 2, height / 2))
			.force("x", d3.forceX())
      .force("y", d3.forceY());


		d3.csv("data/networks_20161030.csv", function (error, data) {
			if (error) throw error;

			// first build the empty data structure
			var nodeData = {
				"nodes": [],
				"links": []
			};

			// loop through our data and populate the json
			data.forEach(function (d, i) {

				// first add all the affiliations as nodes
				for (var i = 1; i <= 19; i++) {

					var aff = 0;

					// if there is an affiliation
					if (d["Affiliation_" + i]) {

						// add the links between body nodes and affiliations as links
						nodeData.links.push({
							"source": d.Body,
							"target": d["Affiliation_" + i]
						})

						// loop through structure to see if we've added
						// this affiliation as a node yet (surely there's a better way?)
						nodeData.nodes.forEach(function (node) {

							// if so, change aff to true
							if (node.id == d["Affiliation_" + i]) {
								aff = 1;
							}
						});

						// if aff is false, add our affiliation to the nodes
						if (aff == 0) {
							nodeData.nodes.push({
								"id": d["Affiliation_" + i],
								"group": i
							})
						}
					}

				}

				// finally add the body organizations as nodes
				nodeData.nodes.push({
					"id": d.Body,
					"group": 0
				})

			}); // nodeData json done

			var link = svg.append("g")
				.attr("class", "links")
				.selectAll("line")
				.data(nodeData.links)
				.enter().append("line")
				.attr("stroke-width", '1.5');

			var node = svg.append("g")
				.attr("class", "nodes")
				.selectAll("circle")
				.data(nodeData.nodes)
				.enter().append("circle")
				.attr("r", 5)
				.attr("fill", function (d) {
					return color(d.group);
				})
				.on('mouseover', function (d) {
					console.log(d)
				})
				.call(d3.drag()
					.on("start", dragstarted)
					.on("drag", dragged)
					.on("end", dragended));

			simulation
				.nodes(nodeData.nodes)
				.on("tick", ticked);

			simulation.force("link")
				.links(nodeData.links);



		function ticked() {

			link
				.attr("x1", function (d) {
					return d.source.x;
				})
				.attr("y1", function (d) {
					return d.source.y;
				})
				.attr("x2", function (d) {
					return d.target.x;
				})
				.attr("y2", function (d) {
					return d.target.y;
				});

			node
				.attr("cx", function (d) {
					return d.x;
				})
				.attr("cy", function (d) {
					return d.y;
				});
		}


	});

	function dragstarted(d) {
		if (!d3.event.active) simulation.alphaTarget(0.3).restart();
		d.fx = d.x;
		d.fy = d.y;
	}

	function dragged(d) {
		d.fx = d3.event.x;
		d.fy = d3.event.y;
	}

	function dragended(d) {
		if (!d3.event.active) simulation.alphaTarget(0);
		d.fx = null;
		d.fy = null;
	}

})();
</script>
</body>

</html>
